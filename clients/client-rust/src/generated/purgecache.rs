#![allow(unused_imports)]
#![cfg_attr(rustfmt, rustfmt_skip)]
/** THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT */
use crate::{Client, Credentials, Retry};
use failure::Error;
use serde_json::Value;
use crate::util::urlencode;

/// Purge Cache Service
///
/// The purge-cache service is responsible for tracking cache-purge requests.
///
/// User create purge requests for specific caches on specific workers, and
/// these requests are timestamped.  Workers consult the service before
/// starting a new task, and purge any caches older than the timestamp.
pub struct PurgeCache (Client);

#[allow(non_snake_case)]
impl PurgeCache {
    pub fn new(root_url: &str, credentials: Option<Credentials>, retry: Option<Retry>) -> Result<Self, Error> {
        Ok(Self(Client::new(root_url, "purge-cache", "v1", credentials, retry)?))
    }

    /// Ping Server
    /// 
    /// Respond without doing anything.
    /// This endpoint is used to check that the service is up.
    pub async fn ping(&self) -> Result<(), Error> {
        let method = "GET";
        let path = "ping";
        let query = None;
        let body = None;

        let resp = self.0.request(method, path, query, body).await?;

        resp.bytes().await?;
        Ok(())
    }

    /// Purge Worker Cache
    /// 
    /// Publish a request to purge caches named `cacheName` with
    /// on `provisionerId`/`workerType` workers.
    /// 
    /// If such a request already exists, its `before` timestamp is updated to
    /// the current time.
    pub async fn purgeCache(&self, provisionerId: &str, workerType: &str, payload: &Value) -> Result<(), Error> {
        let method = "POST";
        let path = format!("purge-cache/{}/{}", urlencode(provisionerId), urlencode(workerType));
        let query = None;
        let body = Some(payload);

        let resp = self.0.request(method, &path, query, body).await?;

        resp.bytes().await?;
        Ok(())
    }

    /// All Open Purge Requests
    /// 
    /// View all active purge requests.
    /// 
    /// This is useful mostly for administors to view
    /// the set of open purge requests. It should not
    /// be used by workers. They should use the purgeRequests
    /// endpoint that is specific to their workerType and
    /// provisionerId.
    pub async fn allPurgeRequests(&self, continuationToken: Option<&str>, limit: Option<&str>) -> Result<Value, Error> {
        let method = "GET";
        let path = "purge-cache/list";
        let mut query = None;
        if let Some(q) = continuationToken {
            query.get_or_insert_with(Vec::new).push(("continuationToken", q));
        }
        if let Some(q) = limit {
            query.get_or_insert_with(Vec::new).push(("limit", q));
        }
        let body = None;

        let resp = self.0.request(method, path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Open Purge Requests for a provisionerId/workerType pair
    /// 
    /// List the caches for this `provisionerId`/`workerType` that should to be
    /// purged if they are from before the time given in the response.
    /// 
    /// This is intended to be used by workers to determine which caches to purge.
    pub async fn purgeRequests(&self, provisionerId: &str, workerType: &str, since: Option<&str>) -> Result<Value, Error> {
        let method = "GET";
        let path = format!("purge-cache/{}/{}", urlencode(provisionerId), urlencode(workerType));
        let mut query = None;
        if let Some(q) = since {
            query.get_or_insert_with(Vec::new).push(("since", q));
        }
        let body = None;

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }
}
