version: 27
migrationScript: 0027-migration.sql
downgradeScript: 0027-downgrade.sql
methods:
  roles_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: auth
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        -- if no roles, return canned "empty" value, as the below expression will return NULL
        perform 1 from roles limit 1;
        if not found then
          return query
          select
            'role',
            'role',
            entity_buf_encode(
              jsonb_build_object(
                'PartitionKey', 'role',
                'RowKey', 'role'),
              'blob', '[]'),
            1,
            gen_random_uuid();
        end if;

        return query
        select 
          'role',
          'role',
          entity_buf_encode(
            jsonb_build_object(
              'PartitionKey', 'role',
              'RowKey', 'role'),
            'blob', jsonb_agg(
              jsonb_build_object(
                'roleId', role_id,
                'scopes', scopes,
                'created', to_js_iso8601(created::text),
                'description', description,
                'lastModified', to_js_iso8601(last_modified::text))
            )::text),
          1,
          -- use an aggregate function to select the etag (all rows have the same etag)
          min(roles.etag::text)::uuid
        from roles;
      end
  roles_entities_create:
    serviceName: auth
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid = gen_random_uuid();
      begin
        -- lock the table, avoiding risk of conflicts when inserting after
        -- finding no rows
        lock table roles;

        perform 1 from roles limit 1;
        if found then
          raise exception 'roles already exist' using errcode = '23505'; -- unique violation
        end if;

        insert into roles
        select 
          (role ->> 'roleId') as role_id,
          (role ->> 'scopes')::jsonb as scopes,
          (role ->> 'created')::timestamptz as created,
          (role ->> 'description') as description,
          (role ->> 'lastModified')::timestamptz as last_modified,
          new_etag as etag
        from jsonb_array_elements(entity_buf_decode(properties, 'blob')::jsonb) as role;

        return new_etag;
      end
  roles_entities_remove:
    serviceName: auth
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        raise exception 'not implemented';
      end
  roles_entities_modify:
    serviceName: auth
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        -- lock the table, avoiding risk of conflicts when inserting after
        -- finding no rows
        lock table roles;

        delete from roles where roles.etag = old_etag;
        if not found then
          -- delete may have done nothing because the table is empty (which is
          -- ok) or because the etag did not match (which is an unsuccessful
          -- update)
          perform role_id from roles limit 1;
          if found then
            raise exception 'unsuccessful update' using errcode = 'P0004';
          end if;
          -- ..otherwise continue to make the modification
        end if;

        insert into roles
        select 
          (role ->> 'roleId') as role_id,
          (role ->> 'scopes')::jsonb as scopes,
          (role ->> 'created')::timestamptz as created,
          (role ->> 'description') as description,
          (role ->> 'lastModified')::timestamptz as last_modified,
          new_etag as etag
        from jsonb_array_elements(entity_buf_decode(properties, 'blob')::jsonb) as role;

        return query select new_etag;
      end
  roles_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: auth
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        raise exception 'not implemented';
      end;
