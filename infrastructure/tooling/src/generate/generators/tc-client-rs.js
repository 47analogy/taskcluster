const util = require('util');
const path = require('path');
const { writeRepoFile, REPO_ROOT } = require('../../utils');
const rimraf = util.promisify(require('rimraf'));
const mkdirp = util.promisify(require('mkdirp'));

const writeRsFile = async (filename, content) => {
  await writeRepoFile(path.join(filename), content.trim() + '\n');
};

const MOD_TEMPLATE = t => `
#![allow(unused_imports)]
#![cfg_attr(rustfmt, rustfmt_skip)]
/** THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT */
use crate::{Client, Credentials, Retry};
use failure::Error;
use serde_json::Value;
use crate::util::urlencode;

${t.description}
pub struct ${t.className} (Client);

#[allow(non_snake_case)]
impl ${t.className} {
    pub fn new(root_url: &str, credentials: Option<Credentials>, retry: Option<Retry>) -> Result<Self, Error> {
        Ok(Self(Client::new(root_url, "${t.serviceName}", "${t.apiVersion}", credentials, retry)?))
    }${t.methods}
}`;

const QUERY_TEMPLATE = t => `\
    if let Some(q) = ${t.name} {
        query.get_or_insert_with(Vec::new).push(("${t.name}", q));
    }`;

const FUNC_TEMPLATE = t => `\
${t.doc}pub async fn ${t.name}(${t.args.join(', ')}) -> Result<${t.okResult}, Error> {
    let method = "${t.method.toUpperCase()}";
    let path = ${t.path};
${t.hasQuery ? `\
    let mut query = None;
${t.query.map(name => QUERY_TEMPLATE({ name })).join('\n')}\
` : `\
    let query = None;\
`}
    let body = ${t.input ? 'Some(payload)' : 'None'};

    let resp = self.0.request(method, ${t.pathFormatted ? '&path' : 'path'}, query, body).await?;

${t.output ? `\
    Ok(resp.json().await?)\
` : `\
    resp.bytes().await?;
    Ok(())`}
}
`;

const generateServiceClient = (className, reference) => {
  const methods = [];

  for (let entry of reference.entries) {
    if (entry.type !== 'function') {
      continue;
    }

    const t = {
      method: entry.method,
      name: entry.name,
    };

    t.args = ['&self'];

    // slice off the leading `/` in the route
    const route = entry.route.slice(1);

    if (entry.args.length) {
      entry.args.forEach(arg => t.args.push(`${arg}: &str`));
      const splitRoute = route.split(/<([a-zA-Z0-9]*)>/);
      const fmtStr = [];
      const fmtArgs = [];
      while (splitRoute.length > 0) {
        const path = splitRoute.shift();
        const argName = splitRoute.shift();
        if (path.length) {
          fmtStr.push(path);
        }
        if (argName) {
          fmtStr.push('{}');
          fmtArgs.push(`urlencode(${argName})`);
        }
      }
      t.pathFormatted = true;
      t.path = `format!("${fmtStr.join('')}", ${fmtArgs.join(', ')})`;
    } else {
      t.pthFormatted = false;
      t.path = `"${route}"`;
    }

    if (entry.input) {
      t.input = true;
      t.args.push('payload: &Value');
    }

    if (entry.output) {
      t.output = true;
      t.okResult = 'Value';
    } else {
      t.output = false;
      t.okResult = '()';
    }

    if (entry.query.length > 0) {
      t.hasQuery = true;
      t.query = entry.query;
      entry.query.forEach(arg => t.args.push(`${arg}: Option<&str>`));
    }

    if (entry.description) {
      let ds = entry.description.trim().split('\n');
      if (entry.title) {
        ds.unshift('');
        ds.unshift(entry.title);
      }
      t.doc = ds.map(l => `/// ${l}`).join('\n') + '\n';
    } else {
      t.doc = '';
    }

    methods.push('\n\n' + FUNC_TEMPLATE(t)
      .trim()
      .split('\n')
      .map(l => l.length > 0 ? '    ' + l : l)
      .join('\n'));
  }

  let description = reference.description.split('\n');
  if (reference.title) {
    description.unshift('');
    description.unshift(`${reference.title}`);
  }
  description = description.map(l => `///${l.length ? ` ${l}` : ''}`).join('\n');

  return MOD_TEMPLATE({
    serviceName: reference.serviceName,
    apiVersion: reference.apiVersion,
    description,
    className,
    methods: methods.join(''),
  });
};

const generateModFile = apis => {
  const mods = [];
  const uses = [];

  for (let [className, { referenceKind }] of Object.entries(apis)) {
    if (referenceKind !== 'api') {
      continue;
    }
    const moduleName = className.toLowerCase();
    mods.push(`mod ${moduleName};`);
    uses.push(`pub use ${moduleName}::${className};`);
  }
  return `${mods.sort().join('\n')}\n\n${uses.sort().join('\n')}\n`;
};

exports.tasks = [{
  title: 'Generate Taskcluster-Client-Rust',
  requires: ['apis'],
  provides: ['target-taskcluster-client-rust'],
  run: async (requirements, utils) => {
    const apis = requirements['apis'];
    const moduleDir = path.join(REPO_ROOT, 'clients', 'client-rust', 'src', 'generated');

    // clean up the clients directory to eliminate any "leftovers"
    utils.status({ message: 'cleanup' });
    await rimraf(moduleDir);
    await mkdirp(moduleDir);

    utils.status({ message: 'mod.rs' });
    await writeRsFile(path.join(moduleDir, 'mod.rs'), generateModFile(apis));

    for (let [className, { reference, referenceKind }] of Object.entries(apis)) {
      if (referenceKind !== 'api') {
        continue;
      }
      const moduleName = className.toLowerCase();

      utils.status({ message: `${moduleName}.rs` });
      await writeRsFile(path.join(moduleDir, `${moduleName}.rs`), generateServiceClient(className, reference));
    }
  },
}];
